### Маркетплейс - Step Third (Servlets and AOP)

Необходимо обновить сервис, доработанный на прошлом шаге, согласно следующим требованиям и ограничениям.

---
#### Требования и ограничения:
- Все взаимодействие должно теперь осуществляться через отправку HTTP запросов.
- Сервлеты должны принимать JSON и отдавать также JSON.
- Для сериализации и десериализации использовать jackson.
- Использовать понятное именование эндпоинтов.
- Возвращать разные статус-коды.
- Добавить DTO (если ранее не было заложено в логике).
- Для маппинга сущностей в дто использовать MapStruct.
- Реализовать валидацию входящих ДТО.
- Сделать Аудит действий пользователя через аспекты.
- Также реализовать на аспектах логирование выполнения любого метода (с замером времени выполнения).
- Сервлеты должны быть покрыты тестами.

---
#### Вариант реализации:

**Стек:**
- Java 17
- Gradle 8.10
- PostgreSQL 14
- Docker (**Version: 28.5.1 - очень важно, версии выше могут быть не совместимы с текущим Testcontainer-ом, треб. доп. конф.**)
- Liquibase
- TomCat JDBC Connection pool
- TomCat Servlet container
- Jakarta Servlets
- Jackson
- MapStruct
- Hibernate Validator
- AspectJ
- JWT

**Тестирование:**
- Testcontainers
- JUnit 5
- Mockito
- AssertJ
- Postman

---
#### Структура проекта:

- [aop](./src/main/java/me/oldboy/market/aop) - папка содержит аннотации и аспекты для реализации АОП (применены к слою контроллеров);
- [config](./src/main/java/me/oldboy/market/config) - папка содержит основные конфигурационные файлы приложения;
  - [ConnectionManager](./src/main/java/me/oldboy/market/config/connection/DbConnectionPool.java) - класс соединения с БД (рабочий и тестовый тип соединения);
  - [ContextApp](./src/main/java/me/oldboy/market/config/context/AppContextBuilder.java) - класс инициализирующий и связывающий основные рабочие части приложения;
  - [LiquibaseManager](./src/main/java/me/oldboy/market/config/liquibase/LiquibaseManager.java) - класс управляющий взаимодействием с миграционным фреймворком;
  - [tomcat](./src/main/java/me/oldboy/market/config/tomcat/EmbeddedTomcat.java) - embedded контейнер сервлетов;
  - [utils](./src/main/java/me/oldboy/market/config/utils) - классы отвечающие за чтение данных из файла свойств [application.properties](./src/main/resources);
- [controllers](./src/main/java/me/oldboy/market/controllers) - набор классов отвечающих за получение запросов из сервлетов и их валидацию;
- [entity](./src/main/java/me/oldboy/market/entity) - ключевые сущности проекта;
- [exceptions](./src/main/java/me/oldboy/market/exceptions) - набор исключений бросаемых приложением в процессе работы;
- [filters](./src/main/java/me/oldboy/market/filters/GlobalEncodingFilter.java) - класс фильтра установки кодировки для request/response взаимодействия на слое web;
- [mapper](./src/main/java/me/oldboy/market/mapper) - набор интерфейсов описывающих преобразования "entity to dto" и обратно;
- [repository](./src/main/java/me/oldboy/market/repository) - классы и методы взаимодействия со слоем данных;
- [security](./src/main/java/me/oldboy/market/security) - набор классов отвечающих за безопасность web-слоя приложения;
- [services](./src/main/java/me/oldboy/market/services) - классы основной бизнес логики;
- [servlets](./src/main/java/me/oldboy/market/servlets) - набор классов web-слоя, отвечающих за взаимодействия с пользователем по средствам HTTP запросов (REST API);
- [validator](./src/main/java/me/oldboy/market/validate) - классы обрабатывающие неверное введение данных в консоли в ключевых точках приложения;
- [MainApp](./src/main/java/me/oldboy/market/MainApp.java) - точка входа в приложение, запускает встроенный TomCat (все общение с приложением через web api);


- [docker-compose.yaml](docker-compose.yaml) - конфигурация сборки PastgreSQL контейнера;
- [.env](.env) - файл для хранения переменных окружения (в нашем случае доступ к БД);

---
- [Тесты](./src/test) - тесты (181 шт.), согласно расчетам IDE покрытие: Class - 84%, Method - 82%; 
- Полное покрытие JavaDoc.

---
#### Запуск (4-и варианта) и тестирование приложения:

Для сборки и запуска необходимо сделать локальную копию приложения:

---
- **Первый вариант** (наиболее простой и надежный для целей изучения и тестов): Запуск и тестирование проекта в среде разработки - IntelliJ IDEA

---
- **Второй вариант**: Консольный запуск приложения. 

Необходимо помнить, что данный проект взаимодействует с PostgreSQL БД развернутой в отдельном контейнере, 
см. [docker-compose.yaml](docker-compose.yaml). Контейнер должен быть запущен и работать перед запуском 
приложения и его тестами, т.к. для проверки работоспособности слоев [repository](./src/test/java/me/oldboy/market/repository) и 
[services](./src/test/java/me/oldboy/market/services) используется функционал [Testcontainer-а](./src/test/java/me/oldboy/market/test_container).

**Шаг 1.** - (На машине должен быть установлен полнофункциональный Docker) В корне текущего проекта находится файл "инструкция"
сборки и запуска контейнера с БД - [docker-compose.yaml](docker-compose.yaml). Запускаем консоль и переходим в корень проекта,
запускаем команду:

    docker-compose up

Убеждаемся, что процесс развертки контейнера прошел нормально и контейнер запущен.

**Шаг 2.** - Запуск тестов. Из корня проекта в консоли передается команда (в зависимости от ОС могут быть проблемы с кодировкой):

    gradlew test

**Шаг 3.** - Сборка Jar файла. Из корня проекта в консоли передается команда:

    gradlew shadowJar

Если все прошло нормально, то в папке build/libs/ проекта появится файл market.jar

**Шаг 4.** - Запуск jar архива:

    java -jar build/libs/market.jar

---
- **Третий вариант**: Генерация war архива и запуск его с развертыванием на внешнем контейнере сервлетов (web-сервере).

Данное приложение (без видимых изменений) может быть запаковано в *.war архив и размещено, например на внешнем TomCat 
сервлет контейнере (без использования того, что подхватывается как внутренняя зависимость). Для этого необходимо, 
в корне проекта, находясь в консоли, использовать команду:

    gradlew war

Если все прошло нормально, то в папке `build/libs/` проекта появится файл `market.war`. Данный war архив необходимо разместить
в корне папки `webapps` вашего TomCat-a (либо вручную, простым копированием), либо используя уже запущенный контейнер по 
средствам его web-интерфейса (кнопка `Manager App`) произвести загрузку вышеописанного *.war архива. 

**Особенности дальнейшего взаимодействия с приложением (если вы выбрали 3-й вариант запуска)**

Ниже, в следующем разделе, приведены все endpoint-ы для работы с приложением, однако в зависимости от способа развертывания 
его будут немного отличаться пути доступа. В случае создания `market.war` и применения его на внешнем TomCat-е к уже 
существующему пути будет прибавлен `префикс` генерируемый сервлет контейнером - сообразно имени war архива. Т.е. если 
у нас есть, например endpoint:

    GET server_path... /market/products/

То теперь, перед ним появится имя war архива `market.war`:

    GET server_path... /market/market/products/

---
- **Четвертый вариант**: Запуск приложения в контейнере.

В корне текущей ветки репозитория находится папка [docker](./docker) с файлами позволяющими развернуть приложение в docker-контейнере:
- [.env](./docker/.env) - настройки окружения;
- [docker-compose.yaml](./docker/docker-compose.yaml) - инструкция для развертывания контейнеров (БД и приложения);

Для запуска процесса необходимо из корня папки [docker](./docker) запустить команду `docker-compose up`. Если все нормально, то 
стартует процесс скачивания необходимых образов с DockerHub-а и далее запуск контейнеров БД и приложения. В идеале, при
запуске на локальной машине, приложение становится доступным по адресу (см. настройки `ports:` [compose файла](./docker/docker-compose.yaml)):

    http://localhost:8081/market/

Описанные ниже endpoint-ы принимают вид, например (`/market/users/login`):

    http://localhost:8081/market/market/users/login

После окончания работы с приложением, все данные сохраняются в volume.

---
#### Взаимодействие с приложением после запуска

Приложение полностью web. Взаимодействие с ним возможно при помощи любого HTTP клиента способного отправлять весь спектр 
запросов (GET, PUT, POST, DELETE и т.д.), например Postman, Insomnia. 

Настройки IP адреса сервера и его порта в файле свойств приложения [application.properties](./src/main/resources/application.properties),
по-умолчанию это `0.0.0.0` (localhost) и `8080` (при выборе 4-го варианта запуска, см. выше - docker контейнер, порт `8081`). 

Приложение обладает минимальной защитой и открывает доступ к своим endpoint-ам с передачей JWT токена. Для его получения 
необходимо залогиниться в системе см. ниже:  

**Авторизация:**
- Логины: `admin@admin.ru` / `user@user.ru` / `manager@manager.ru`;
- Пароли: `1234` / `4321` / `1111`;

**API Endpoints:**

1. Авторизация ("вход в систему"), любой из 3-х предложенных выше (в теле запроса).
- `POST /market/users/login`: 

      {
        "email": "admin@admin.ru",
        "password": "1234"
      }

После удачной авторизации пользователь получает ответ вида:

      {
        "id": 1,
        "email": "admin@admin.ru",
        "role": "ADMIN",
        "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbkBhZG1pbi5ydSIsImlkIjoxLCJyb2xlIjoiQURNSU4iLCJleHAiOjE3NjM4Nzk0ODJ9.ulxy6t9jYVC-8d-agVpRKe6GF9dANh9OlFJyZjVtlmw"
      }

Полученный токен доступа необходимо использовать при любом запросе к интересующему endpoint-у, вставляя в соответствующее 
поле вашего HTTP клиента, в Postman это Authorization, тип аутентификации Bearer Token. 

2. Управление товаром:
- `POST /market/products/` : Создание товара (пример json object);

       {
         "name": "Примус",
         "price": 210.0,
         "categoryId": 1,
         "brandId": 4,
         "description": "5 л.ч.",
         "stockQuantity": 5
       }

- `PUT /market/products/` : Обновление существующего товара (пример json object):

       {
         "id": "8",
         "name": "Грабли",
         "price": 540.0,
         "description": "Гребут, окучивают",
         "stockQuantity": 2
       }

- `DELETE /market/products/8` : Удаление существующего товара по ID; 
- `GET /market/products/3` : Получение товара по ID;
- `GET /market/products/` : Получение всех доступных товаров (список);
- `GET /market/products/categories/1` : Получить все товары из категории с заданным ID;
- `GET /market/products/brands/1` : Получить все товары брэнда с заданным ID;
- `GET /market/products?prodName=Валенки` : Получить товар по его названию;

3. Просмотр категорий:
- `GET /market/categories/` : Получение всех доступных категорий товаров;
- `GET /market/categories/1` : Получение одной категории по ее ID;

4. Просмотр брэндов:
- `GET /market/brands/` : Получение всех доступных брэндов товаров;
- `GET /market/brands/1` : Получение одного брэнда по его ID;

5. Просмотр аудит записей:
- `GET /market/audits/` : Получить все аудит записи;
- `GET /market/audits/1` : Получить аудит запись с заданным ID;
- `GET /market/audits?userEmail=user@user.ru` : Получить список всех аудит записей для конкретного пользователя по его email;

---
#### Особенности

Техническое задание данного проекта не предусматривает возможность регистрации нового пользователя, ТОЛЬКО авторизация 
пользователя и все, судя по всему предполагается, что новые пользователи добавляются (и управляются) другим способом или
из другого сервиса приложения. Однако на слое репозиториев реализована и протестирована полная CRUD функциональность 
с управляемым просачиванием ее "на верхние слои приложения" не только для пользователей, но и для всех применяемых 
сущностей - "на перспективу". 

---
#### Работа над ошибками

- При "конфигурации контекста" и отдельных классов применены интерфейсные ссылки;
- Применен пул соединений с БД;  
- Учтен недочет с ручным управлением коммитами транзакций;
- В более емких тестах (где на один метод приходится более 3-х тестов) логическое разделение блоков комментариями заменено на @Nested с @DisplayName;